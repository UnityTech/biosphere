#!/usr/bin/ruby

require 'biosphere'
require 'optparse'
require 'ostruct'
require 'pp'
require "awesome_print"
require 'colorize'
require 'biosphere/s3.rb'
require 'pty'

class BiosphereOpts

    def self.parse(args)

        options = OpenStruct.new
        options.build_dir = "build"
        options.src = "./"
        options.force = false
        options.version = ::Biosphere::Version

        opt_parser = OptionParser.new do |opts|


            opts.banner = "Usage: \"biosphere [options] <action>\""

            opts.separator ""
            opts.separator "Commands:"
            opts.separator "\tbuild\tWrite tf files as json into build directory"
            opts.separator "\tplan\tRun the planning phase"
            opts.separator "\tcommit\tCommit changes and update the infrastructure"
            opts.separator "\tlock\tAcquire lock for remote state"
            opts.separator "\tunlock\tRelease lock for remote state"
            opts.separator "\taction [action]\tCall an action defined in the application .rb files"
            opts.separator ""

            opts.on_tail("-h", "--help", "Show this message") do
                puts opts
                exit
            end

            opts.on("--src PATH", "Directory where the application .rb files are") do |path|
                options.src = path
            end

            opts.on("--build-dir PATH", "Directory where to build json files") do |path|
                options.build_dir = path
            end

            opts.on_tail("-v", "--version", "Show version") do
                puts options.version
                exit
            end

            opts.on("--force", "Don't prompt for user input") do
                options.force = true
            end

        end

        opt_parser.parse!(args)
        options
    end

end

if !STDOUT.isatty
    String.disable_colorization true
end

update_info = Biosphere::CLI::UpdateManager::check_for_update()
if !update_info[:up_to_date]
    STDERR.puts "Notice. There is a new #{update_info[:latest]} biosphere version available. Your current version is #{update_info[:current]}\nUse \"gem install biosphere\" to update".colorize(:yellow)
end


options = BiosphereOpts.parse(ARGV)

if ARGV.length == 0
    STDERR.puts "No action spesified. Use -h to get help."
    exit(-1)
end

if !File.directory?(options.src)
    STDERR.puts "Directory #{options.build_dir} is not a directory or it doesn't exists."
    exit(-1)
end

if options.build_dir
    if !File.directory?(options.build_dir)
        STDERR.puts "Creating build directory #{options.build_dir} because it was missing"
        Dir.mkdir(options.build_dir)
    end
end

if options.src
    state = Biosphere::State.new
    suite = Biosphere::Suite.new(state)

    if options.src == "./"
        STDERR.puts "Loading suite from current directory (#{File.expand_path(options.src)}). Use --src to change the path"
    end

    # We need to load the suite once so that we can find the Biosphere settings
    begin
        if suite.load_all(options.src) == 0 || suite.deployments.size == 0
            STDERR.puts "No files found. Are you in the right directory where your biosphere .rb files are?"
            exit(-1)
        end
    rescue ::Biosphere::ConfigurationError => e
        STDERR.puts "Configuration Error: #{e}".colorize(:red)
        if e.explanation
            STDERR.puts e.explanation
        end
        if e.settings
            STDERR.puts "Relevant configuration part:"
            ap e.settings
        end
        exit(-1)
    end

    if suite.biosphere_settings[:local] == true
        localmode = true
    else
        localmode = false
        if suite.biosphere_settings[:s3_bucket].nil? || suite.biosphere_settings[:s3_bucket].empty? ||
            suite.biosphere_settings[:state_name].nil? || suite.biosphere_settings[:state_name].empty?
            puts "\nNo S3 bucket or cluster name defined in configuration, can't continue"
            exit 1
        end
        s3 = S3.new(suite.biosphere_settings[:s3_bucket], suite.biosphere_settings[:state_name])
        s3.retrieve("#{options.build_dir}/state.node")
    end

    # This will update the state which is already passed to the suite.
    state.filename = "#{options.build_dir}/state.node"
    if File.exists?(state.filename)
        puts "Loading state from #{state.filename}"
        state.load()
    end

    destroyed_deployments = state.node[:deployments].keys - suite.deployments.keys
    if destroyed_deployments.length > 0
        destroyed_deployments.each do |deployment_name|
            answer = Biosphere::CLI::Utils::ask_question("State file has remins of an old deployment #{deployment_name}. Do you want to clean these now?", ['y', 'n'], force: options.force)
            if answer == "y"
                puts "Clearing #{deployment_name}"
                state.node[:deployments].delete(deployment_name)
            else
                puts "Leaving #{deployment_name}, this might affect for example action kubectl."
            end
        end
    end

    unless state.node[:deployments][""].nil?
        puts "State contains deployments with empty names. Remember to clean these out with rename-deployment, this state won't work with Kubernetes".colorize(:red)
    end
end

# If we are doing something which is allowed to modify the state
if ["build", "action", "commit"].include?(ARGV[0])
    if !state.node[:biosphere]
        state.node[:biosphere] = {}
    end
    state.node[:biosphere][:version] = ::Biosphere::Version
end

if ARGV[0] == "build" && options.src
    Biosphere::CLI::Build::build(suite, s3, options.build_dir, ARGV[1], force: options.force)

elsif ARGV[0] == "plan" && options.src
    suite.evaluate_plans()
    ap suite.node, :indent=>-4

elsif ARGV[0] == "state" && options.src
    ap suite.state.node, :indent=>-4    

elsif ARGV[0] == "action" && options.src
    Biosphere::CLI::Action::action(suite, s3, options.build_dir, ARGV[1])

elsif ARGV[0] == "deployment" && options.src

    suite.deployments.each do |name, deployment|
        puts "Deployment: #{name}"
    end

elsif ARGV[0] == "statereset" && options.src
    Biosphere::CLI::StateReset::statereset(suite, s3, options.build_dir, force: options.force)

elsif ARGV[0] == "commit" && options.src
    Biosphere::CLI::Commit::commit(suite, s3, options.build_dir, force: options.force)

elsif ARGV[0] == "destroy" && options.src
    Biosphere::CLI::Destroy::destroy(suite, s3, options.build_dir, ARGV[1], force: options.force)

elsif ARGV[0] == "lock"
    if localmode
        STDERR.puts "lock not supported in local mode (set in Settings :biosphere[:local] = true"
        exit(-1)
    end

    s3.set_lock()

elsif ARGV[0] == "unlock"
    if localmode
        STDERR.puts "unlock not supported in local mode (set in Settings :biosphere[:local] = true"
        exit(-1)
    end

    s3.release_lock()

else
    STDERR.puts "\nERROR: Unknown command #{ARGV[0]}. Maybe you wanted to do: \"biosphere action #{ARGV[0]}\"?"
    exit(-1)
end
